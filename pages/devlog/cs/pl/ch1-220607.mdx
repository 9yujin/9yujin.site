import { Img } from "components";

# 1. 프로그래밍 언어 소개

_2022.06.07_

## 1.3 추상화 : readability 증가 목적

#### 양에 따른 분류

- 기본 추상화 : 가장 지엽적인 기계정보에 대한 추상화
- 구조 추상화 : 보다 전역적인 정보인 프로그램의 구조에 대한 추상화
- 단위 추상화 : 단위 프로그램 전체에 대한 정보의 추상화

#### 범주

- 자료 추상화 : 문자열, 숫자와 같은 계산될 자료의 특성을 추상화 → **데이터**
- 제어 추상화 : 실행순서를 제어하는 특성을 추상화 → **알고리즘**  
  ex\) 반복문, 조건문, 프로시저 호출 등

#### 자료 추상화

- 기본 : 컴퓨터 내부 자료 \(Data type 추상화)
- 메모리 주소 : 변수로 추상화
- 자료의 값 : 2진수를 10진수 실수형으로 추상화
- 구조 : 연관된 데이터 집합을 추상화 \(배열, 레코드, struct) typedef \(구조형에 새 이름 부여 기능)
- 단위 : 자료의 생성, 폐기, 사용에 관한 정보를 모아두고 접근을 제한  
  데이터 정의, 인터페이스, 값들을 하나로 캡슐화 \(c++의 class → ADT)

#### 제어 추상화

- **기본** : 몇개의 기계 명령어를 모아 이해하기 쉬운 추상 구문화

> 배정문 \(x := x+y) / 분기문 \(if goto) 등등

- **구조** : 검사 값에 따라 분할된 명령어 그룹 수행

> 단일 state 구문들이 조합돼서 하나의 구문을 이룸.  
> \- 택일문 \(if, case, switch) / 반복문 \(for, while 등등) / 강력한 구조 제어(프로시저)

- **단위** : procedure들이 모여서 하나의 그룹을 추상화

> 여러 작업들을 모아서 하나의 단위 프로그램화 / 라이브러리  
> ex\) C++/JAVA의 class, ADA의 package

#### 별개의 추상화기법

- 병행 프로그래밍\(동기화, 통신 개념 지원)  
  ex\) coroutine, task, process

## 1.4 계산 전형 \(computational paradigms)

#### 명령형 \(impertative) / 절차적\(procedural) 언어

- 명령의 순차적 실행 (병목현상) - 변수 사용 / 배정문 사용
- 많은 자료의 동시 계산, 순서에 의존하지 않는 계산에 비효율적 → 병목현상  
  ex - C, ADA, Pascal, Fortran, Basic 등 대부분 언어  
  명령형 계산 전형의 단점을 보완하기 위해 함수형/논리형 등이 나옴.

#### 함수형 \(functional) / 적용형 \(applicative) 언어

- 함수를 만들고 → **평가**하고 → **적용**하기 위해 호출
- 변수, 배정문이 없음
- 반복 연산은 재귀적 함수 이론에 의해 기술됨

#### 논리형 \(logical) / 선언형 \(declarative) 언어

- 기호 논리학 \(p이면 q이다..) 에 근거
- 논리적인 기술을 먼저 하고, 거따가 뭘 하는거같은데..
- 반복이나 선택 개념 불필요

#### 객체 지향 언어

- 객체에 기반
- 객체 : 상태를 의미하는 **기억 장소**와 상태를 변경할 수 있는 **연산**의 집합 \(변수, 함수)
- 객체는 클래스로 그룹화
- Simula67 이 최초

## 1.5 언어 정의

- 구문\(syntax) 정의와 의미\(semantics) 정의
- **구문 정의** : 대부분의 언어가 문맥 자유 문법 \(context free grammer)를 만족하며,  
  BNF로 정의 → 형식화가 잘 되어 있음
- **의미 정의 :** 의미는 프로그램 실행 시 어떤 일이 발생하는가를 기술  
  ex\) if문에서 거짓일때, else문 이하가 존재하기 않을 경우  
  의미론의 형식적 정의 방법 : denotational / axiomatic
